Q136. LeetCode : Single Number ?


Q137. LeetCode: Single Number || ?
üîπ Step-by-Step Implementation : 
Step 1: Take Input
             int arr [] = {2,2,3,2}
Step 2: Initialize Result Variable 
                               - int res = 0;
Step 3: Traverse Bit Positions (0 ‚Üí 31)
                         for (int i = 0; i < 32; i++) // becoz ek integer me 32 bit hote hai to 0 th index se 31st index tak sab bit check krna hai.                          
Step 4: Count Set Bits at Position i
                            int bitCount = 0;
Step 5: now use another foreach loop to pick array element and check the ith bit is set or not, if bit set then increase bit count.
                            for (int num : arr) {
                               if ((num & (1 << i)) != 0) {
                                        bitCount++;
                              }
                           }
Step 5: Remove Triplet Effect, becasue agr bit count ka 3 modulo krne pe remainder aa rha hai iska mtlb ye whi num hai jo apna extra bit countribute kiya hoga. to usko result me set kr dena hai.
                         if (bitCount % 3 != 0) {
                             res = res | (1 << i);
                           }
Step 6: Print Result
System.out.println(res);




Q260. LeetCode: Single Number ||| ?
Input : {1,2,1,3,2,5}
Approach :
- first of all sabhi elements ka xor krenge , jisse jo same element hoga 0 ho jayega and 3 ^ 5 reh jayega. where
 3 : 0 1 1
^
 5 : 1 0 0 
-----------
     1 1 0 = 6
- ab 6 ka binary se ek koi v bit chahiye group krne k liye numbers ko, so we'll pick first right most bit becoz we have study.
  so for finding rsb is:  xor & -xor = 0 1 0
 now with the help of first right most bit we need to do & of all number to know kis number me bit set hai or kisme nhi. agr set nhi hai to ek grp me orna dusre grp me.
1 -> 0 0 1
2 -> 0 1 0
3 -> 0 1 1
5 -> 1 0 1

Step-by-Step Implementation :
Step 1: Array define karo
int[] arr = {1, 2, 1, 3, 2, 5};
Step 2: Sab elements ka XOR nikalo
int xor = 0;
for (int num : arr) {
    xor = xor ^ num;
}
  - Same numbers ka XOR = 0 hota hai.
  - xor = a ^ b (sirf dono unique numbers bachenge). xor = 3 ^ 5 = 6
Step 3: Rightmost Set Bit (RSB) nikaalo
int rsb = xor & (-xor);
   - rsb ek mask hai jo dono unique numbers ko alag-alag group me baantne ke kaam aata hai
   - Ye bit batata hai ki a aur b kis bit par different hain
   Example:
        xor = 6  (110)
        rsb = 2  (010)
Step 4: Array ko 2 groups me divide karo
int xorA = 0;
int xorB = 0;

for (int num : arr) {
    if ((num & rsb) != 0) {
        xorA = xorA ^ num;
    } else {
        xorB = xorB ^ num;
    }
}
  - Jis number me rsb bit set hai ‚Üí Group A
  - Jis me set nahi hai ‚Üí Group B
  - Har group me duplicate numbers cancel ho jaate hain
Step 5: Result store aur print karo
int[] res = new int[]{xorA, xorB};

for (int re : res) {
    System.out.println(re);
}



Q2220. LeetCode:  Minimum Bit Flips to Convert Number ?
Input: start = 10, goal = 7
Output: 3
Explanation :
10 : 1 0 1 0
7  : 0 1 1 1
so 10 ke binary ko 0-index wale,2-index wale,3-index wale, bit ko flip krne pe 7 ho jayega. so iske liye xor ka use kr skte hai like 10 ^ 7 = 13 jo ki 1 1 0 1 hota hai ab
isme check krna hai kitne bit set hai isse ye pta chlega ki kitne bit different rhe honge.
Step-by-Step Implementation :
Step 1: Start aur Goal numbers define karo
int start = 3, goal = 4;
  - Ye wo do numbers hain jinke bits compare karne hain.
Step 2: Dono numbers ka XOR nikaalo
int xor = start ^ goal;
             - XOR me same bits ‚Üí 0
             - different bits ‚Üí 1
             - Jitne 1 honge, utne hi bit flips chahiye
             Example:
                     3  = 0011
                     4  = 0100
                     -----------
                     xor= 0111
Step 3: Flip count ke liye variable initialize karo
int count = 0;
Step 4: XOR me set bits count karo (Brian Kernighan‚Äôs Algorithm)
while (xor > 0) {
    xor = xor & (xor - 1);
    count++;
}
  - xor & (xor - 1) har iteration me rightmost set bit remove karta hai
  - Har loop = ek bit flip
Step 5: Final count print karo
System.out.println(count);




Q78. LeetCode : Subsets ?
Defination :
Subset ‡§ï‡§æ ‡§Æ‡§§‡§≤‡§¨ ‡§π‡•ã‡§§‡§æ ‡§π‡•à ‡§ï‡§ø‡§∏‡•Ä ‡§¨‡§°‡§º‡•á ‡§∏‡•á‡§ü (Set) ‡§ï‡§æ ‡§õ‡•ã‡§ü‡§æ ‡§π‡§ø‡§∏‡•ç‡§∏‡§æ, ‡§ú‡§ø‡§∏‡§ï‡•á ‡§∏‡§æ‡§∞‡•á elements ‡§â‡§∏ ‡§¨‡§°‡§º‡•á ‡§∏‡•á‡§ü ‡§Æ‡•á‡§Ç ‡§Æ‡•å‡§ú‡•Ç‡§¶ ‡§π‡•ã‡§Ç‡•§
ex- Set A = {1, 2, 3}
Possible subsets:
total = 2¬≥ = 8 hote hain. because hr element ke liye 2 choice hai either u can take or not.
{} ‚Üí Empty Set
{1}
{2}
{3}
{1, 2}
{1, 3}
{2, 3}
{1, 2, 3}
Ye sab A ke subset hain kyunki inke saare elements A me already exist karte hain.
üí° Important Points :
- Empty set {} har set ka subset hota hai
- Full set bhi apna khud ka subset hota hai
- Order matter nahi karta: {1,2} = {2,1}
- Duplicate allowed nahi hota (set rule)
                                               ‚úÖ Subset vs Subsequence vs Substring (Comparison Table) :
                                  
                                     | Feature             | Subset      | Subsequence    | Substring                  |
                                     | ------------------- | ----------- | -------------- | -------------------------- |
                                     | Works on            | Set / Array | Array / String | String only                |
                                     | Order matters?      | ‚ùå No       | ‚úÖ Yes        | ‚úÖ Yes                     |
                                     | Continuous?         | ‚ùå No       | ‚ùå No         | ‚úÖ Yes (must be continuous)|
                                     | Empty allowed?      | ‚úÖ Yes      | ‚úÖ Yes        | ‚ùå Usually no              |
                                     | Total count formula | 2^n         | 2^n            | n(n+1)/2                   |


STEPS TO IMPLEMENT :

1. takes input :
            int [] arr = {1,2,3};
2. use formula to find subsets like, 2^nums.length;
            int ss = 1<<nums.length;
3. Outer Loop ‚Üí Iterate Over All Bitmasks :
            for(int i = 0; i < ss; i++) {
4. Create New List for Each Subset :
            List<Integer> list = new ArrayList<>();
5. Inner Loop ‚Üí Check Each Bit :
            for(int j = 0; j < arr.length; j++) {
6. Bit Checking Condition :
           if ((i & (1 << j)) != 0) {
               list.add(arr[j]);
            }
7. Store Subset :
             subset.add(list);
8. return all subsets :
        return subsets;







