2                                                                                BIT MANIPULATION-BASIC 

******** NUMBER REPRESENTATION ********
 1. Decimal number representation: 
         (432)‚ÇÅ‚ÇÄ  =  4√ó10^2+3√ó10^1+2√ó10^0  => 400+30+2 => 432
 2. Binary Number representation :
          (1011)‚ÇÇ  =  (1√ó2^3)+(0√ó2^2)+(1√ó2^1)+(1√ó2^0)  => 8 + 2 + 1  => 11

TABLE OF BINARY NUMBER :
| Decimal | Binary |
| ------- | ------ |
| 1       | 0001   |
| 2       | 0010   |
| 3       | 0011   |
| 4       | 0100   |
| 5       | 0101   |
| 6       | 0110   |
| 7       | 0111   |
| 8       | 1000   |
| 9       | 1001   |
| 10      | 1010   |

Q1. What is Bit (Binary Digit ) ?
 - A bit is the smallest unit/box of data in a computer.
 - It can have only two possible values ‚Äî 0 or 1.
üí° Think of it like a simple switch:
0 means OFF
1 means ON
Computers use bits to store and process all kinds of information ‚Äî numbers, letters, images, and even videos ‚Äî by combining many bits together.
Example:
1 bit ‚Üí can represent 2 values ‚Üí 0 or 1   ya 0/1
2 bits ‚Üí can represent 4 values ‚Üí 00, 01, 10, 11
3 bits ‚Üí can represent 8 values ‚Üí 000 , 001 , 010 , 011 , 100 , 101, 110 , 111
Note:- bit means digits either 0 is digit or 1 is a digit.

Note:-
    - if there is n bits so The maximum number you can represent starting from 0  to  (2^‚Åø) ‚àí 1
    - If you have n bits, they can form 2‚Åø unique combinations of 0s and 1s.
    - üëâ Each combination is one distinct pattern that represents one value.
    - Example :
               - 4 bits = a group of 4 binary digits (like 0000 or 1101).
               - 5 bits = a group of 5 binary digits (like 00000 or 10110).

üß† 1Ô∏è‚É£ Bit Positions ‚Äì MSB and LSB :
| Term    | Full Form             | Meaning                               | Example (for 8-bit number `10110100`) |
| ------- | --------------------- | ------------------------------------- | ------------------------------------- |
| **MSB** | Most Significant Bit  | Leftmost bit (highest value position) | **1**0110100                          |
| **LSB** | Least Significant Bit | Rightmost bit (lowest value position) | 1011010**0**                          |

structure :
üëâ MSB -------- LSB
Example:
1 0 1 1 0 1 0 0
‚¨ÜÔ∏è MSB‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚¨áÔ∏è LSB

üß© 2Ô∏è‚É£ Signed vs Unsigned Numbers apply on MSB :
| Type                | Sign Information                                  | MSB Role                                         |largest Range for integer |
| ------------------- | ------------------------------------------------- | -------------------------------------------------| -------------------------| 
| **Unsigned Number** | ‚ùå No sign (only positive values)                  | MSB is just another value bit                   | 2^31-1                   |
| **Signed Number**   | ‚úÖ MSB shows the sign (0 = positive, 1 = negative) | MSB denotes sign, remaining bits show magnitude | [‚àí2^31, 2^31-1           |


üß© Set bit & Unset bit :
| Bit Value | Kya kehte hain            
| --------- | ------------------------- 
| `1`       | **Set bit khte hai**      
| `0`       | **Unset bit / Clear bit khte hai** 


Q2. üß† Bit Addition (Binary Addition) ?
recall decimal addition :
                            2 7 4
                          + 9 8 7
                          ----------
                         1 2 6 1
same way binary addition :
                            1 0 1    => 5
                          + 1 1 1    => 7
                          ---------
                           1 1 0 0    => 12
Note in both addition when sum of two numbers/digits become two digits like 9+2 = 11 then carry 1 to next one in left direction.



üìò Number System & Signed Binary Representation ?
----------------------------------------------------

1Ô∏è‚É£ Positive numbers ko binary me kaise store karte hain?
             - Positive decimal number ko simply binary me convert karke store kar dete hain.
             - Example (4 bits):  +5 = 0101
                                  +1 = 0001       Koi issue nahi,Sab smooth ‚úÖ

2Ô∏è‚É£ Problem negative numbers ke saath aati hai?
            - Agar hum negative numbers ko bhi direct binary me likhne lag gaye:   +5  ‚Üí 101
                                                                                   -1  ‚Üí 101
                                                        - Problem:
                                                               - Same binary 101.
                                                               - CPU kaise decide kare: ye +5 hai ya -1?
                                                               - Binary me sign ka clear rule nahi hai,Isliye system chahiye jo: positive & negative ko clearly alag kare ya arithmetic operation like,(addition/subtraction) easy banaye
                                                               - Yahin se complement system aaya.
                                                             
3Ô∏è‚É£ Signed Number ka basic idea :
                           - MSB (Most Significant Bit) ko sign bit mana jata hai:  0 ‚Üí positive
                                                                                    1 ‚Üí negative
                           - But sirf sign bit enough nahi.Isliye complement methods use hote hain.

4Ô∏è‚É£ 1‚Äôs Complement ‚Äì Concept:
                      - Definition: 1‚Äôs complement = binary bits ko invert kar do :  0 ‚Üí 1
                                                                                     1 ‚Üí 0
                      - Example (4 bits):   +2 = 0010
                                            -2 = 1101   (1‚Äôs complement)
                         - Ab add karo: 
                                          0010
                                        + 1101
                                         ------
                                          1111   ‚Üí -0 ‚ùå
                      - ‚ùå Problem with 1‚Äôs complement:    +0 = 0000
                                                           -0 = 1111    Math me +0/-0 sense nahi banata.

5Ô∏è‚É£ 2‚Äôs Complement ‚Äì WHY introduced?
          - Single representation of 0.
          - for Easy subtraction using addition.
          - HOW it works? :
                      - 2‚Äôs complement = 1‚Äôs complement + 1
          - Example:  ‚àí5 (4 bits) :
               - Step 1: Binary of +5 ( we ignore singed during conversion decimal to binary).
                        +5 = 0101
               - Step 2: 1‚Äôs complement (flip/invert) :
                         0101 ‚Üí 1010
               - Step 3: Add 1   :
                            1010
                          +    1
                          ------
                           1011




BIT MANUPULATION 
_________________________________

Q4. Bitwise Operators  ?

1Ô∏è‚É£ AND (&)
Definition: 
Compares each bit of two numbers and returns 1 if both bits are 1, otherwise 0.
b1       operator     b2               result
0          &          0                  0
0          &          1                  0
1          &          0                  0
1          &          1                  1
Example : 
5 & 3 ‚Üí 
        0 1 0 1 
      & 0 0 1 1 
     -------------
        0 0 0 1 
 Output (0001) ‚Üí 1 


                                                                       üß† Bitwise AND (&) ‚Äì Practice Table :

                                  
                                          | Q.No | Expression              | Your Guess |
                                          | ---- | ----------------------- | ---------- |
                                          | 1    | `5 & 3`                 | ____       |
                                          | 2    | `6 & 4`                 | ____       |
                                          | 3    | `7 & 1`                 | ____       |
                                          | 4    | `8 & 7`                 | ____       |
                                          | 5    | `10 & 12`               | ____       |
                                          | 6    | `x & 0`                 | ____       |
                                          | 7    | `x & x`                 | ____       |
                                          | 8    | `x & 1`                 | ____       |
                                          | 9    | `9 & 1`                 | ____       |
                                          | 10   | `8 & 1`                 | ____       |
                                          | 11   | `8 & 7`                 | ____       |
                                          | 12   | `16 & 15`               | ____       |
                                          | 13   | `12 & 10`               | ____       |
                                          | 14   | `15 & 1`                | ____       |
                                          | 15   | `n & (n - 1)` *(n = 8)* | ____       |
                                          | 16   | `n & (n - 1)` *(n = 6)* | ____       |


2Ô∏è‚É£ OR (|)
Definition:
Compares each bit of two numbers and returns 1 if any one of the bits is 1, otherwise 0 | 0 then 0  or  1 | 1 then 1.
b1       operator     b2               result
0          |          0                  0
0          |          1                  1
1          |          0                  1
1          |          1                  1
Example :
5 | 3 ‚Üí 
        0 1 0 1 
      & 0 0 1 1 
     -------------
        0 1 1 1 
Output (0111) ‚Üí 7



                                                                      üß† Bitwise OR (|) ‚Äì Practice Table :

                                                     | Q.No | Expression          | Your Guess |
                                                     | ---- | ------------------- | ---------- |
                                                     | 1    | 5 | 3               | ____       |
                                                     | 2    | 6 | 4               | ____       |
                                                     | 3    | 7 | 1               | ____       |
                                                     | 4    | 8 | 7               | ____       |
                                                     | 5    | 10 | 12             | ____       |
                                                     | 6    | x | 0               | ____       |
                                                     | 7    | x | x               | ____       |
                                                     | 8    | x | 1               | ____       |
                                                     | 9    | 9 | 1               | ____       |
                                                     | 10   | 8 | 1               | ____       |
                                                     | 11   | 16 | 15             | ____       |
                                                     | 12   | 12 | 10             | ____       |
                                                     | 13   | 15 | 1              | ____       |
                                                     | 14   | n | (n - 1) (n = 8) | ____       |
                                                     | 15   | n | (n - 1) (n = 6) | ____       |




3Ô∏è‚É£ XOR (^)
Definition:
Compares each bit and returns 1 if bits are different, otherwise 0.
b1       operator     b2               result
0          ^          0                  0
0          ^          1                  1
1          ^          0                  1
1          ^          1                  0
Example:
5 ^ 3 ‚Üí 
        0 1 0 1 
      ^ 0 0 1 1 
     -------------
       0 1 1 0
Output(0110) ‚Üí 6



                                                                                 üß† Bitwise XOR (^) ‚Äì Practice Table :

                                                              | Q.No | Expression          | Your Guess |
                                                              | ---- | ------------------- | ---------- |
                                                              | 1    | 5 ^ 3               | ____       |
                                                              | 2    | 6 ^ 4               | ____       |
                                                              | 3    | 7 ^ 1               | ____       |
                                                              | 4    | 8 ^ 7               | ____       |
                                                              | 5    | 10 ^ 12             | ____       |
                                                              | 6    | x ^ 0               | ____       |
                                                              | 7    | x ^ x               | ____       |
                                                              | 8    | x ^ 1               | ____       |
                                                              | 9    | 9 ^ 1               | ____       |
                                                              | 10   | 8 ^ 1               | ____       |
                                                              | 11   | 16 ^ 15             | ____       |
                                                              | 12   | 12 ^ 10             | ____       |
                                                              | 13   | 15 ^ 1              | ____       |
                                                              | 14   | n ^ (n - 1) (n = 8) | ____       |
                                                              | 15   | n ^ (n - 1) (n = 6) | ____       |


4Ô∏è‚É£ NOT (~)
Definition: 
Flips all bits (0 ‚Üí 1, 1 ‚Üí 0). used for 1's complement, and agr not of (~) agr ek negative num ata hai ~(-num) to hum iska 2's complement nikalte hai. agr not of (~) ek positive num ata
hai ~ (+num) to hum apan operation stop kr dete hai. agr app ek negative num ka hee not (~) nikal rhe hai to first 2's complement me solve krenge then uska not ~ nikalenge then again 
follow same rule : {"and agr not of (~) agr ek negative num ata hai ~(-num) to hum iska 2's complement nikalte hai. agr not of (~) ek positive num ata
hai ~ (+num) to hum apan operation stop kr dete hai".}
Example :
~7 ‚Üí  
Original binary of 7 : 0 1 1 1
Apply ~ on 7         : 1 0 0 0   bit flips here
                    -----------
   then becomes      1 0 0 0  so here MSB is 1 means negative, Ye decision ab ho chuka hai so follow the rule. 
                     find 2's complement :      
                                          1's complement : 0 1 1 1 
                                          2's complement :      +1 
                                   so after solving  :   1 0 0 0  but we got's 2's complement result here but in during bit flip already MSB preserve ho chuka hai ki neg hai, so wha se MSB mil jayega.
that's why
Output(1000) ‚Üí -8 actually 1000 is decimal 8 but applied ~ not of (~) operator to so -neg will be result. which is -8.

Trick to Find Not(~) Of a number :
~(num) = - (num+1)
eg-
~(7) = -(7+1) 
     = -8
~(-7) = - ( -7+1)
      = - (-6)
      = 6
Note:-  Not of (~) applied krne pe bit flip hoga in any how, but sirf value nikalne ke liye 2‚Äôs complement use karte hain: uske liye above rule apply hoga.


                                                                                       üß† Bitwise NOT (~) ‚Äì Practice Table  :

                                                                  | Q.No | Expression | Your Guess |
                                                                  | ---- | ---------- | ---------- |
                                                                  | 1    | ~0         | ____       |
                                                                  | 2    | ~1         | ____       |
                                                                  | 3    | ~5         | ____       |
                                                                  | 4    | ~7         | ____       |
                                                                  | 5    | ~8         | ____       |
                                                                  | 6    | ~10        | ____       |
                                                                  | 7    | ~(-1)      | ____       |
                                                                  | 8    | ~(-5)      | ____       |
                                                                  | 9    | ~x         | ____       |
                                                                  | 10   | ~~5        | ____       |



5Ô∏è‚É£ Right Shift (>>)
Definition: 
Shifts all bits to the right by n positions.
  - For signed numbers, MSB (sign) is copied/presever agr original num ka singed 0 tha to 0 hee rhega ya 1 tha to 1 hee rhega.
  - Example:
5 >> 1
        0 1 0 1
     >> 1
     -----------
       0 0 1 0
Output(0010) ‚Üí 2
Note: Right shift by K formula:
num >> k = num / 2^k

Example:
11 >> 1:

Original bits:  1     0     1     1 <------ ye remove ho jayega.
Bit power:      2¬≥    2¬≤    2¬π    2‚Å∞

After >>1:      0     1     0     1
Bit power:      2¬≥    2¬≤    2¬π    2‚Å∞
Decimal: 5
‚úÖ Explanation for clarity:
           - MSB 1 moves right ‚Üí falls off (or in signed, depends)
           - LSB 1 dropped
           - New MSB filled with 0 (unsigned right shift)



                                                                                  üß† Right Shift (>>) ‚Äì Practice Table  :

                                                                      | Q.No | Expression | Your Guess |
                                                                      | ---- | ---------- | ---------- |
                                                                      | 1    | 8 >> 1     | ____       |
                                                                      | 2    | 8 >> 2     | ____       |
                                                                      | 3    | 7 >> 1     | ____       |
                                                                      | 4    | 5 >> 1     | ____       |
                                                                      | 5    | 10 >> 1    | ____       |
                                                                      | 6    | -8 >> 1    | ____       |
                                                                      | 7    | -5 >> 1    | ____       |
                                                                      | 8    | x >> 1     | ____       |
                                                                      | 9    | x >> 2     | ____       |
                                                                      | 10   | 1 >> 1     | ____       |



6Ô∏è‚É£ Unsigned Right Shift (>>>) (Java specific)
Definition:
Shifts bits to the right, filling 0s on the left, ignoring sign ab sign neg tha ya pos after unsigned right shift alway Msb 0 rhega mtlb number ko positive bna dega after shift.
Example:
-5 >>> 1 fills left bits with 0 ‚Üí large positive number



                                                                                       üß† Unsigned Right Shift (>>>)‚Äì Practice Table  :

                                                                        | Q.No | Expression | Your Guess |
                                                                        | ---- | ---------- | ---------- |
                                                                        | 1    | 8 >>> 1    | ____       |
                                                                        | 2    | 8 >>> 2    | ____       |
                                                                        | 3    | 7 >>> 1    | ____       |
                                                                        | 4    | 5 >>> 1    | ____       |
                                                                        | 5    | 10 >>> 1   | ____       |
                                                                        | 6    | -8 >>> 1   | ____       |
                                                                        | 7    | -5 >>> 1   | ____       |
                                                                        | 8    | x >>> 1    | ____       |
                                                                        | 9    | x >>> 2    | ____       |
                                                                        | 10   | 1 >>> 1    | ____       |



7Ô∏è‚É£ Left Shift (<<)
Definition:
Shifts all bits to the left by n positions, filling with 0s on the right. 
Example:
5 << 1 
       0 1 0 1
    << 1 
   -------------
     1 0 1 0 
Output(1010) ‚Üí 10

Note: Left shift by K formula:
num << k = num * 2^k
11 << 1:

Original bits:   1     0     1     1
Bit power:       2¬≥    2¬≤    2¬π    2‚Å∞

After <<1:       1     0     1     1     0
Bit power:       2‚Å¥    2¬≥    2¬≤    2¬π    2‚Å∞

Decimal: 22
‚úÖ Explanation for clarity:
    - All bits move 1 place left
    - New LSB filled with 0 which is nothing but a magnitude value.
    - MSB shifted into new position (may cause overflow if bit-size exceeded)


                                                                                            üß† Left Shift (<<) ‚Äì Practice Table  :

                                                                             | Q.No | Expression | Your Guess |
                                                                             | ---- | ---------- | ---------- |
                                                                             | 1    | 5 << 1     | ____       |
                                                                             | 2    | 5 << 2     | ____       |
                                                                             | 3    | 3 << 3     | ____       |
                                                                             | 4    | 8 << 1     | ____       |
                                                                             | 5    | 1 << 4     | ____       |
                                                                             | 6    | 10 << 1    | ____       |
                                                                             | 7    | x << 1     | ____       |
                                                                             | 8    | x << 2     | ____       |
                                                                             | 9    | 7 << 1     | ____       |
                                                                             | 10   | 4 << 3     | ____       |


Q1. follow-up : odd - even check ?
Note:-
for this,we need to know kisi v num ki LSB kya hai? if LSB=0 then it is even. if LSB=1 then it is odd. why because sare bit 2 ka kch n kuch power contribute kr rhe hai except last bit.
so one of the bit operators which is & will help with 1 .
Input:
int num = 5;  // on Neg(-5) also work on same logic.
Output: odd.



Q2. swap two numbers (without using third variables and without using arithmetic operator) ?
int a = 13;
int b = 11;
here, we can use one of the operators of xor(^)
Explanation :
a = a^b;
b= a^b; 
 = a^b^b;
 = a;

a = a ^ b;
  = a ^ b ^ a
  = b; 

Explantion on Bit level :
a = 13;     1 1 0 1
b = 11;     1 0 1 1
a = a^b;    0 1 1 0
b = a^b;    1 1 0 1  (13)
a = a^b;    1 0 1 1  (11)


