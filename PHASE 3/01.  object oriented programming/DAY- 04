---------------------------------------------------------------------- Polymorphism -----------------------------------------------------------------------------------------
ğŸ”¹ What is Polymorphism? 
it is one of the principle of oops where the same method call on a parent reference, executes different method implementations depending on the runtime object. 
it is combination of two word : Poly = Many ,  Morph = Forms.

ğŸ”· Why?
âœ” Code flexibility
âœ” Behavior change allowed
âœ” Achieves loose coupling (after abstraction)
âœ” Improves scalability & maintainability


ğŸ”¹ Core Requirement for Runtime Polymorphism :
                                       - Inheritance required
                                       - Method Overriding required
                                       - Parent reference + Child object    eg- Parent p = new Child(); // mandatory
âš ï¸ Sirf methods ke saath possible, âŒ Variables, constructors, static methods polymorphism ka part nahi hote



ğŸ”¹ Why Parent Reference = Child Object?
Parent p = new Child();
p.method();
   - Reference decide karta hai kaunsa method call ho sakta hai
   - Object decide karta hai kaunsa overridden version chalega.
âœ… Parent reference ka fayda :
                                    Car car;
                                          if(type.equals("electric")) {
                                                  car = new ElectricCar();
                                          } else {
                                                 car = new PetrolCar();
                                          }   car.drive(); // SAME LINE, DIFFERENT BEHAVIOR
âœ” Runtime decision
âœ” No code duplication
âœ” Open for extension, closed for modification (SOLID Principle)


âœ… Allowed & Not Allowed Combinations ?
| Code                       | Valid? | Reason                    |
| -------------------------- | ------ | ------------------------- |
| `Parent p = new Child();`  | âœ…     | Runtime polymorphism      |
| `Child c = new Parent();`  | âŒ     | Child cannot refer parent |
| `Parent p = new Parent();` | âŒ     | No polymorphism           |
| `Child c = new Child();`   | âŒ     | No polymorphism           |



ğŸ”¹ Casting Analysis (POLYMORPHISM SUPPORTING PART) ?

âŒ Case-1 (Invalid Downcasting)  :
Parent p = new Parent();
Child c = (Child) p; // Runtime error ClassCastException
 reson :=> Reference cast ho sakta hai, object cast nahi hota. But runtime pe JVM object ko check karta hai â€” reference ko nahi.

âœ… Case-2 (Safe Downcasting) :
Parent p = new Child(); // Upcasting
Child c = (Child) p;   // Safe downcasting
 reson :=> Actual object = Child, Reference change ho raha hai, object nahi.
  

â— Important Note ?
âŒ Method Overloading polymorphism ka part nahi hai
   - Overloading:
             - Compile-time decision
             - Inheritance required nahi.
             - Isliye Overloading is an independent language feature.
In Depth Explanantion: Method overloading technically polymorphism ka core part nahi hai,lekin behavior â€œsame method name â†’ different formsâ€ dikhata hai, isliye academically / textbooks me 
                       ise Compile-time Polymorphism bol dete hain.
              
ğŸ”· Types of Polymorphism :
| Type         | Decision Time | How                | Real Polymorphism? |
| ------------ | ------------- | ------------------ | ------------------ |
| Compile-time | Compile time  | Method Overloading | âŒ NO              |
| Runtime      | Runtime       | Method Overriding  | âœ… YES             |
Note:- Real polymorphism = Runtime polymorphism only.



Example: 

âœ… Compile-time Polymorphism (Method Overloading) :

class Test {

    void m1(Object obj) {
        System.out.println("Object version called");
    }

    void m1(String name) {
        System.out.println("String version called");
    }

    public static void main(String[] args) {

        Test t = new Test();

        t.m1("sahil");  // Output = String version called
    }
}


âŒ Ambiguous case (compile-time error)  :

class Test {

    void m1(String s) {}
    void m1(StringBuilder sb) {}

    public static void main(String[] args) {
        Test t = new Test();
        t.m1(null); // âŒ compile-time error
    }
}




ğŸ…°ï¸ Method Overloading (Compile-time Polymorphism) :
Rule:-
------
  1. Same method name 
  2. No. of parameters are same(data types different)                             eg- (String email,boolean true) or ( int age,char ch).
  3. data types same ( order different )                                          eg- (String name,int age) or (int age,String name)
  4. no. of parameters are different then well & good , already polymorphism.      eg-(double price) or (float f,String password).
âœ” Return type may differ,
âŒ Only return type change â†’ Not allowed (parameters must differ).


compile-time ambiguity cases :
------------------------------
ğŸ”¹ Case-1: int-double vs double-int
âŒ Problem :
              void m1(int a, double b) {}
              void m1(double a, int b) {}
              dog.m1(10, 10); // ambiguous
âœ… Solutions :
âœ” Solution-1: Explicit casting
            dog.m1(10, 10.0);
            dog.m1((int)10, (double)10);
âœ” Solution-2: Exact match method add karo
            void m1(int a, int b) {}
âœ” Solution-3: Method name change (BEST design)
          void m1IntDouble(int a, double b) {}
          void m1DoubleInt(double a, int b) {}

ğŸ”¹ Case-2: null with String vs StringBuilder
âŒ Problem :
            void m1(String s) {}
            void m1(StringBuilder sb) {}
            dog.m1(null); // ambiguous
âœ… Solutions :
âœ” Solution-1: Explicit casting
           dog.m1((String) null);
           dog.m1((StringBuilder) null);
âœ” Solution-2: Common parent + override
           void m1(Object o) {}
âœ” Solution-3: Method rename (clean design)
           void m1String(String s) {}
           void m1StringBuilder(StringBuilder sb) {}

ğŸ”¹ Case-3: Wrapper classes ambiguity
âŒ Problem :
           void m1(Integer i) {}
          void m1(Double d) {}
          dog.m1(null); // ambiguous
âœ… Solutions :
âœ” Solution-1: Explicit casting 
           dog.m1((Integer) null);
           dog.m1((Double) null);
âœ” Solution-2: Use Object
         void m1(Object o) {}
âœ” Solution-3: Avoid overload on wrappers
         - Industry best practice, Use meaningful method names instead.

ğŸ”¹ Case-4: Autoboxing + Widening
âŒ Problem :
           void m1(int a, long b) {}
           void m1(long a, int b) {}
           dog.m1(10, 10); // ambiguous
âœ… Solutions :
âœ” Solution-1: Force type
          dog.m1(10, 10L);
          dog.m1(10L, 10);
âœ” Solution-2: Add exact signature
         void m1(int a, int b) {}

ğŸ”¹ Case-5: Var-args confusion
âŒ Problem :
           void m1(int... a) {}
           void m1(int a, int b) {}
           dog.m1(10, 20); // ambiguous
âœ… Solutions :
âœ” Solution-1: Remove var-args if not needed
âœ” Solution-2: Use array explicitly
           dog.m1(new int[]{10, 20});




ğŸ…±ï¸ Method Overriding (Runtime Polymorphism)
Child class changes parentâ€™s method behavior
âœ” Same name
âœ” Same parameters
âœ” Same return type / covariant(Parent se chhota (child type)) return type
âœ” Must be in different classes with inheritance
âœ” IS-A relationship (inheritance)



ğŸ”¥ Runtime Polymorphism Example (Object Reference Game!) ?
-----------------------------------------------------------
class Animal {
    void sound() {
        System.out.println("Animal sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Bark");
    }
}

Animal a = new Dog();
a.sound(); // Bark

ğŸ“Œ Decision runtime pe hota hai :
                          - Reference â†’ Animal
                          - Object â†’ Dog
                          - Dog ne override kiya â†’ Dog ka method call
â“ Agar override nahi kiya?
                          - Parent ka method call hoga



ğŸ”¹ Overriding Special Rules (Polymorphism ke andar) ?
-------------------------------------------------------
âœ” Access Modifier
             - Child method more restrictive nahi ho sakta
âœ” Exception Rule
             - Checked exception â†’ same or narrower
âœ” Return Type
             - Covariant return type allowed
âœ” Can overridden method call parent method?
             - YES ğŸ‘‰ using super.method()




ğŸ“Œ Concepts Related to Inheritance ?
            âŒ Variables (Instance & Static) :
                                      - Override nahi hote
                                      - Sirf hidden
                                      - Compile-time binding
                                      - Reference type decides
                                      - ex: A obj = new B();
                                            System.out.println(obj.x); // Parent variable
            âŒ Static Methods :
                          - Override nahi hote
                          - Method hiding hoti hai
                          - Compile-time binding
                          - Reference decides
                          - ex :  A obj = new B();
                                  obj.staticMethod(); // Parent version
            âŒ Constructors :
                         - Override nahi hote
                         - reason : Because a constructorâ€™s name must be exactly the same as its class name, and when a class is inherited, the class name changesâ€”so the constructor cannot belong to the child class.
                         - eg :  class A {
                                      A() { System.out.println("A"); }
                                  }
                                 class B extends A {
                                       B() { 
                                        super(); // calls parent constructor, does NOT inherit
                                      System.out.println("B"); 
                                  }}
                                 
            âŒ Private Methods :
                           - Override nahi hote
                           - Compile-time binding
            âŒ Final Methods :
                           - Override nahi hote

 Note:- Binding = method call ko actual method se jodna
  a. Compile-time binding (Early binding/static binding) â†’ Kaunsa method call hoga, compiler pehle hi decide kar leta hai     
  b. Runtime binding (Late binding/dynamic binding) â†’ Execution time pe decide hota hai (polymorphism).





