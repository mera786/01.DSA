------------------------------------------------------------------- 4Ô∏è‚É£ What is Abstraction? ------------------------------------------------------------------------------------------------
Abstraction is hiding the implementation details /internal working and showing only the essential features(like, Start/Stop engine,Accelerate / Brake without knowing how to start...)  to the user.
Think of it like: when you drive a car, you use the steering, brake, and accelerator without knowing how the engine works inside.
Why?
‚úî To reduce complexity
‚úî To show only necessary details
‚úî To improve code maintainability
‚úî To define a blueprint for other classes
üß© How to Achieve Abstraction in Java
There are 2 main ways to achieve abstraction:
1Ô∏è‚É£ Using Abstract Classes 
2Ô∏è‚É£ Using Interfaces
üåüDifference Between Abstract Class and Interface ?
| Feature                          | Abstract Class                                                                    | Interface                                                                                                                |
| -------------------------------- | --------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| **Object Creation**              | Cannot create object directly                                                     | Cannot create object directly                                                                                            |
| **Methods**                      | Can have **abstract methods** (without body) and **concrete methods** (with body) | All methods are **abstract by default** (before Java 8). From Java 8+, can have **default and static methods with body** |
| **Fields (Variables)**           | Can have **instance variables** of any type; can be non-final                     | Variables are **public, static, final by default** (constants)                                                           |
| **Constructors**                 | Can have constructors, becoz constructor ka kam obj intialize krna na ki obj creat| Cannot have constructors,isliye by default variables final and static hote h qunki intialize hee nhi kr skte static=baher se access|
| **Multiple Inheritance**         | Supports **single inheritance only** (extends one class)                          | Supports **multiple inheritance** (a class can implement multiple interfaces)                                            |
| **Access Modifiers for Methods** | Can use `private`, `protected`, `public`                                          | Methods are **public by default** (cannot use private for abstract methods before Java 9)                                |
| **Inheritance**                  | `extends` keyword is used                                                         | `implements` keyword is used                                                                                             |
| **Purpose**                      | To provide **partial abstraction** + some shared code                             | To provide **full abstraction / contract** for classes                                                                   |
| **When to Use**                  | When classes are closely related and share **common code**                        | When classes are **unrelated** but must follow the same **rules/contract**                                               |
| **Default Implementation**       | Can provide **default method body**                                               | Java 8+ allows **default methods**; Java < 8, **no method body allowed**                                                 |
| **Static Methods**               | Can have static methods                                                           | Can have static methods (Java 8+)                                                                                        |
Note:
Abstract:-
- abstract method can't be final,static and private.



üåüDifference Between Encapsulation and Abstraction ?
| Feature                   | Encapsulation                                                                                                 | Abstraction                                                                                           |
| ------------------------- | ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| **Definition**            | Wrapping **data (variables) + methods** together and controlling access                                       | Hiding **implementation details** and showing only essential features                                 |
| **Focus**                 | Focuses on **data protection**                                                                                | Focuses on **hiding implementation/internal working**                                                 |
| **Access Control**        | Achieved by **access modifiers** (`private`, `protected`, `public`) and **getters/setters**                   | Achieved by **abstract classes** or **interfaces**                                                    |





                                                                         MCQ OOPS
                                                                        -----------

Q1.

class A {
    static void show() {
        System.out.println("A");
    }
}

class B extends A {
    static void show() {
        System.out.println("B");
    }
}

public class Test {
    public static void main(String[] args) {
        A a = new B();
        a.show();
    }
}


Output: A



Q2. Which statements are TRUE?
- A final method can be overloaded
- A final class can implement an interface
- A private method can be overridden
- A constructor can be static
Output: A) 1 & 2


Q3. 
class Parent {
    void test(Object o) {
        System.out.println("Object");
    }

}

class Child extends Parent {
    void test(String s) {
        System.out.println("String");
    }
}

public class Demo {
    public static void main(String[] args) {
        Parent p = new Child();
        p.test("Hello");
    }
}
Output: Object because Yahan overriding ho hi nahi rahi ‚ùå. Signature same nahi hai, isliye overriding nahi, balki overloading hai.
        or jab p.test("Hello") kr rhe hai to child class ka test method compile time pe visible hee nhi hai compiler ko. jab ki normal method overloading me overloading 
        methods visible hote hain.



Q4. will it give compile time error or not ?
class Parent {
     Parent() {
     print();
    }

    void print(){

    }    
}
Output: No, perfectly valid, Non-static ‚Üí Non-static ko call kr skte hai.



Q5.
class Base {
    Base() {
        print();
    }

    void print() {
        System.out.println("Base");
    }
}

class Derived extends Base {
    int x = 10;

    Derived() {
        print();
    }

    void print() {
        System.out.println(x);
    }
}

public class Test {
    public static void main(String[] args) {
        new Derived();
    }
}


Output:
0
10


Q6. 

interface A {
    default void show() {
        System.out.println("A");
    }
}

interface B {
    default void show() {
        System.out.println("B");
    }
}

class C implements A, B {
    public void show() {
        A.super.show();
    }
}

public class Test {
    public static void main(String[] args) {
        new C().show();
    }
}

Output: A 
if show not overriden in C then it give us ambiguity problem.




Q7. Can we override a method and reduce visibility?
protected void process() {}
Overridden as:
void process() {}
why ?
Ans : protected ‚Üí visible to subclasses + same package 
Overriding rule: Overridden method must have same or wider visibility.


Q8. What will break if equals() is overridden but hashCode() is not?
Ans : HashMap trusts hashCode() first and equals() later ‚Äî if hashCode lies, equals never gets a chance.


Q9. Which Solid principle is violated?
class PaymentService {
    void pay(String type) {
        if(type.equals("CARD")) { ... }
        else if(type.equals("UPI")) { ... }
        else if(type.equals("NETBANKING")) { ... }
    }
}

Output: Open‚ÄìClosed Principle : instead of doing this Create abstraction

